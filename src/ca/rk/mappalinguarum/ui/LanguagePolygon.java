package ca.rk.mappalinguarum.ui;

import java.awt.Color;
import java.awt.Point;
import java.awt.Polygon;
import java.util.ArrayList;
import java.util.Iterator;

import ca.rk.mappalinguarum.exceptions.IllegalPolygonException;
import ca.rk.mappalinguarum.model.Language;
import ca.rk.mappalinguarum.model.Location;
import ca.rk.mappalinguarum.ui.interfaces.IObserver;
import ca.rk.mappalinguarum.util.Colour;
import ca.rk.mappalinguarum.util.RandomColourGenerator;


/**
 * represents a polygonal area on the map that serves as a visual indicator of a
 * language's distribution
 * 
 * @author RK
 *
 */
public class LanguagePolygon implements IObserver {

	private Map map;
	private Location encapsulatedLocation;
	private Colour colour;
	private Colour familyDerivedColour;
	private Polygon polygon;
	private double[] latitudes;
	private double[] longitudes;
	private ArrayList<Integer> xPoints;
	private ArrayList<Integer> yPoints;
	private boolean isHighlighted;
	
	/**
	 * constructs a LanguagePolygon; remembers the Map container and takes the Location input
	 * object as the basis for building its polygon
	 * 
	 * @param m the Map object that contains the LanguagePolygon
	 * @param loc the Location object to wrap around
	 */
	public LanguagePolygon(Map m, Location loc) {
		map = m;
		encapsulatedLocation = loc;
		colour = encapsulatedLocation.getColour();
		familyDerivedColour = encapsulatedLocation.getLanguage().getUrFamily().getColour();
		familyDerivedColour = RandomColourGenerator.getInstance().mixColours(familyDerivedColour, colour);
		isHighlighted = false;
	}
	
	/**
	 * construct the polygon from Location information and map zoom level
	 * return null if the polygon has fewer than three vertices within the viewport
	 * 
	 * @param l the Location object to use
	 * @param zoomLevel the current zoom level in the map viewer
	 * @return a Polygon, null if there's nothing to draw
	 * @throws IllegalPolygonException if an illegal polygon is detected
	 */
	private Polygon constructPolygon(Location l, int zoomLevel) throws IllegalPolygonException {
		latitudes = l.getLatitudes();
		longitudes = l.getLongitudes();
		if (xPoints == null) {
			xPoints = new ArrayList<Integer>(longitudes.length);
		}
		if (yPoints == null) {
			yPoints = new ArrayList<Integer>(latitudes.length);
		}
		
		xPoints.clear();
		yPoints.clear();
		
		Point point;
		for (int i = 0; i < latitudes.length; ++i) {
			//force the map viewer to return a non-null Point even if it's outside of the viewport
			point = map.getMapPosition(latitudes[i], longitudes[i], false);
			
			xPoints.add(point.x);
			yPoints.add(point.y);
		}
		
		//unequal number of x and y points means something is wrong
		if ( xPoints.size() != yPoints.size() ) {
			throw new IllegalPolygonException();
		}
		
		//a polygon with fewer than three vertices makes no sense
		if (xPoints.size() < 3) {
			return null;
		}
		
		//convert ArrayLists to primitive arrays, since Polygon only accepts those
		int[] xArray = new int[ xPoints.size() ];
		int[] yArray = new int[ yPoints.size() ];
		Iterator<Integer> xIterator = xPoints.iterator();
		Iterator<Integer> yIterator = yPoints.iterator();
		
		for (int i = 0; i < xArray.length; ++i) {
			xArray[i] = xIterator.next();
			yArray[i] = yIterator.next();
		}

		return new Polygon(xArray, yArray, xArray.length);
	}
	
	/**
	 * whether the input point is within the polygon
	 * 
	 * @param p the input point
	 * @return true if this.polygon contains p, otherwise false
	 */
	public boolean contains(Point p) {
		//null polygon contains nothing
		if (polygon == null) {
			return false;
		}

		return polygon.contains(p);
	}

	@Override
	public void update() {
		try {
			polygon = constructPolygon(encapsulatedLocation, map.getZoom() );
			if (polygon != null) {
				polygon.invalidate();
			}
		}
		catch(IllegalPolygonException ipe) {
			TextConsole.writeLine("There was an error calculating one of the language areas.");
		}
	}

	/**
	 * generated by Eclipse
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((encapsulatedLocation == null) ? 0 : encapsulatedLocation.hashCode());
		return result;
	}

	/**
	 * generated by Eclipse
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (!(obj instanceof LanguagePolygon)) {
			return false;
		}
		LanguagePolygon other = (LanguagePolygon) obj;
		if (encapsulatedLocation == null) {
			if (other.encapsulatedLocation != null) {
				return false;
			}
		}
		else if (!encapsulatedLocation.equals(other.encapsulatedLocation)) {
			return false;
		}
		return true;
	}

	/**
	 * gets a Color object depending on the ViewMode and whether the LanguagePolygon is highlighted;
	 * in family mode, return the family-derived colour as a Color; otherwise, return own colour;
	 * if highlighted in either case, return a lightened shade of the underlying colour
	 * 
	 * @return a Color object
	 */
	public Color getColor() {
		if (map.getViewMode() == ViewMode.FAMILIES) {
			if (isHighlighted) {
				return RandomColourGenerator.getInstance().lightenColour(familyDerivedColour).toColor();
			}
			return familyDerivedColour.toColor();
		}
		if (isHighlighted) {
			Color c = RandomColourGenerator.getInstance().lightenColour(colour).toColor();
			return c;
		}
		return colour.toColor();
	}
	
	//accessors
	public Location getEncapsulatedLocation() { return encapsulatedLocation; }
	public Language getEncapsulatedLanguage() { return encapsulatedLocation.getLanguage(); }
	public Polygon getPolygon() { return polygon; }
	public boolean getIsHighlighted() { return isHighlighted; }
	
	public void setIsHighlighted(boolean b) { isHighlighted = b; }
}
